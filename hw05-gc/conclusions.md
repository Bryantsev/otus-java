Вводные данные:
Процессор: AMD FX-8350, 4GHz
Оперативная память: 16 Gb
Требуемая JDK для запуска: 12.0.2
Параметры запуска приложения для теста работы сборщика мусора: --enable-preview -Xms5120m -Xmx5120m -XX:+Use<gc>, где <gc> сборщик мусора
Команда запуска из папки target со сгенерированным jar-файлом gcmeter.jar: <путь к JDK-12.0.2>\bin\java -cp ./gcmeter.jar ru.otus.lesson9.Main 
(например, c:\app\java\jdk-12.0.2\bin\java -cp ./gcmeter.jar ru.otus.lesson9.Main )

Список сборщиков мусора и профили для запуска, как и параметры запуска тестов, зашиты в классе ru/otus/lesson9/Main.java

Сборщики мусора: "G1GC", "ParallelGC", "SerialGC", "ConcMarkSweepGC"
Профили (стартовое суммарное кол-во кэш- и рабочих объектов 10_000_000, кол-во циклов 100) с нарастанием стартого кол-ва "кэш"-объектов относительно 
  кол-ва рабочих объектов (создаваемых и уничтожаемых) - % кэш-объектов относительно рабочих объектов: 0, 50, 100, 150, 500 
- без утечки памяти 
- и с утечкой памяти 20% от кол-ва рабочих объектов

Результаты тестовых прогонов приведены в файлах папки hw05-gc/logs.

Выводы по работе сборщиков мусора в зависимости от профиля нагрузки приложения (соотношения количества постоянных/кэш- и рабочих объектов) 
в ***однопоточном*** приложении и настройках сборщиков мусора со значениями по умолчанию:
1. При отсутствии утечек памяти (т.е. моделируем ситуацию, что верхняя граница памяти задана адекватно потребностям приложения, и оно не занимает всю выделенную память).

Рейтинг сборщиков в зав-сти от профиля (% кэша) по максимальной производительности без утечек памяти
Сборщик          | 0% | 50% | 100% | 150% | 500% | Выводы
-----------------|----|-----|------|------|------|----------------------------------------------------------------------------------------------------
SerialGC         | 1  | 1   | 1    | 2    | 2    | Лучший сборщик при сопоставимом или меньшем кол-ве кэш-объектов относительно рабочих объектов
                 |    |     |      |      |      | Замечания: использует меньшее кол-во ресурсов системы для своей работы, чем ParallelGC, но больше, чем G1GC
ParallelGC       | 2  | 2   | 2    | 1    | 1    | Лучший сборщик при значительно большем кол-ве кэш-объектов относительно рабочих объектов
                 |    |     |      |      |      | Замечания: использует большее кол-во ресурсов системы для своей работы, чем SerialGC
ConcMarkSweepGC  | 3  | 3   | 3    | 3    | 3    | 3ье место по затратам ресурсов на свою работу, проигрывая ParallelGC  
                 |    |     |      |      |      | 
G1GC             | 4  | 4   | 4    | 4    | 4    | 4ое место по суммарной производительности, хотя ресурсов системы потребляет меньше всех 
                 |    |     |      |      |      | 
-----------------|----|-----|------|------|------|----------------------------------------------------------------------------------------------------

Лучше всего отработал сборщик SerialGC, который запускался меньшее кол-во раз и, хотя время, затраченное непосредственно на его работу, больше, чем у
G1GC, но суммарное время, затраченное на ту же самую полезную работу, оказалось самым низким почти при всех профилях нагрузки.

Рядом с SerialGC держались сборщики ParallelGC и ConcMarkSweepGC, сокращая разрыв с увеличением относительного процента постоянных/кэш- объектов,
а при профиле 500% кэш-объектов ParallelGC даже вырвался вперед.

Без утечек памяти, т.к. постоянные кэш-объекты занимали один и тот же объем и не выходили за границу памяти, выделенную под old generation, major-сборщик вообще не запускался. 

2. При наличии утечек памяти 20% за цикл (т.е. моделируем ситуацию, когда выделенной памяти для приложения недостаточно, 
либо периодически случаются пиковые нагрузки, поглощающие всю память).

Рейтинг сборщиков в зав-сти от профиля (% кэша) по максимальной производительности и количеству обработанных объектов до падения с ошибкой OOM с утечками памяти 20% за цикл
Сборщик          | 0% | 50% | 100% | 150% | 500% | Выводы
-----------------|----|-----|------|------|------|----------------------------------------------------------------------------------------------------
G1GC             | 1  | 1   | 1    | 1    | 1    | Лучший сборщик по количеству обработанных объектов до падения по ошибке OOM
                 |    |     |      |      |      |  
SerialGC         | 2  | 2   | 2    | 2    | 2    | Обрабатывает несколько меньше объектов, чем G1GC, т.к. быстрее падает по ошибке
                 |    |     |      |      |      | 
ConcMarkSweepGC  | 3  | 3   | 3    | 3    | 3    | 3ье место по затратам ресурсов на свою работу и количеству обработанных объектов до ошибки  
                 |    |     |      |      |      | 
ParallelGC       | 4  | 4   | 4    | 4    | 4    | 4ое место по суммарной производительности (кол-ву обработанных объектов до ошибки). 
                 |    |     |      |      |      | Большую часть системных ресурсов потребил сам, проработав в разы дольше остальных сборщиков, 
                 |    |     |      |      |      | практически тормозя всю систему, вместо того, чтобы упасть по ошибке, а не пытаться сделать невозможное 
-----------------|----|-----|------|------|------|----------------------------------------------------------------------------------------------------

Как ни странно, но при более агрессивной работе приложения рейтинг развернулся, выдвинув на 1ое место сборщик G1GC, бывший последним в предыдущий раз.
При этом SerialGC также показал достойный результат. А вот ConcMarkSweepGC и ParallelGC в условиях ограниченных ресурсов показали себя не лучшим образом,
особенно отличился ParallelGC, который по сути в холостую загружал работать систему, пытаясь сделать невозможное. 


Итоговый вывод
Выбор сборщика мусора необходимо делать на основе предполагаемого профиля работы системы, обеспечив приложению достаточное
количество ресурсов.
